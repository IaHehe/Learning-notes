# c++面向对象

> 成功来自于坚持不懈的努力

## 1. 类和对象

**定义一个c++类**

```c++
class Box{
  public:
  	double length;
  	double breath;
  	double height;
};
```

**定义c++对象**

```c++
#include <iostream>  
using namespace std;  
class A  
{  
private:  
    int n;  
public:  
    A(int m):n(m)  
    { }  
    ~A(){}  
};  
int main()  
{  
    A a(1);  //栈中分配  
    A b = A(1);  //栈中分配  
    A* c = new A(1);  //堆中分配  
　　delete c;  
    return 0;  
}  
```

第一种和第二种没什么区别，一个隐式调用，一个显式调用，两者都是在进程虚拟地址空间中的栈中分配内存，而第三种使用了new，在堆中分配了内存，而栈中内存的分配和释放是由系统管理，而堆中内存的分配和释放必须由程序员手动释放。采用第三种方式时，必须注意一下几点问题：

1. new创建类对象需要指针接收，一处初始化，多处使用
2. new创建类对象使用完需delete销毁
3. new创建对象直接使用堆空间，而局部不用new定义类对象则使用栈空间
4. new对象指针用途广泛，比如作为函数返回值、函数参数等
5. 频繁调用场合并不适合new，就像new申请和释放内存一样
6. 栈的大小远小于堆的大
7. 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率 比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在 堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会 分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

---

**访问数据成员**

+ 在栈中分配内存的对象，使用"."运算符访问数据成员
+ 在堆中分配内存的对象，使用"->"运算符访问数据成员

**构造函数**

```c++
class Counter{
  public:
  	//类Counter的构造函数
  	Counter(){
      m_value = 0;
  	}
  private:
  	int m_value;
}
```

构造函数的种类

```c++
class Complex{
  private:
  	double m_real;
  	double m_imag;
  public:
  	//无参数构造函数
  	//若无任何构造函数，系统会自动生成默认的无参构造函数，函数为空，什么都不做
  	//只要有下面任何一种构造函数，系统则不会自动生成默认的构造函数
  	Complex(void){
      m_real = 0.0;
      m_imag = 0.0;
  	}
  	
  	//一般构造函数(也称重载构造函数)
  	//一般构造函数可以有各种参数形式，一个类可以有多个一般构造函数，前提是参数的个数或者类型不同
  	//创建对象时根据传入的参数不同调用不同的构造函数
  	Complex(double real, double imag){
      m_real = real;
      m_imag = imag;
  	}
  
  	//复制构造函数(也称重载构造函数)
  	//复制构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中		 会将已存在对象的数据成员的值复制一份到新创建的对象中
  	//若没有显示的写复制构造函数，则系统会默认创建一个复制构造函数，但当类中有指针成员时，由系统默认创建		 该复制构造函数会存在风险
  	Complex(const Complex &c){
      //将对象c中的数据成员值复制过来
      m_real = c.m_real;
      m_img = c.m_img;
  	}
  
  
}
```





**类成员函数**

成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，例如add,read和print等，他们的定义和声明都在类的外部。



**类的访问修饰符**

+ 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。
+ 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了类的实现细节。



**友元**

类可以允许其他类或者函数访问他的非公有成员，方法是令其他类或者函数成为它的友元(friend)。

也就是说有两种形式的友元：

1. 友元函数：普通函数访问某个类中的私有或保护成员
2. 友元类：类A中的成员函数访问类B中

特性

1. 提高了程序的运行效率
2. 破坏了类的封装性和数据的透明性

如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可：

```c++
friend <类型><友元函数名>(<参数表>)
```

> 注意：友元函数只是一个普通函数，并不是该类的类成员函数，它可以在任何地方调用，友元函数通过对象名来访问该类的私有或保护成员

```c++
class A{
  public:
  	A(int _a):a(_a){};
}
```


